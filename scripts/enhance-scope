#!/bin/sh
# commit-msg:
# enhance commit messages touching a single file to include the filename in the summary

# File containing the commit message
COMMIT_MSG_FILE=$1

COMMIT_CONTENT=$(cat "$COMMIT_MSG_FILE")
# Extract first line and rest using POSIX-compliant parameter expansion
NL='
'
COMMIT_SUMMARY="${COMMIT_CONTENT%%"${NL}"*}"
COMMIT_BODY="${COMMIT_CONTENT#*"${NL}"}"
# If no newline, body is empty
[ "$COMMIT_BODY" = "$COMMIT_CONTENT" ] && COMMIT_BODY=""

# Get the list of files touched in the commit
FILES_TOUCHED=$(git diff --cached --name-only)

# Count files by counting non-empty lines (matching original logic)
if [ -z "$FILES_TOUCHED" ]; then
	exit 0
fi

# Count files by counting lines (handles filenames with spaces correctly)
FILE_COUNT=$(printf '%s\n' "$FILES_TOUCHED" | grep -c .)

# If the commit doesn't touch exactly one file, exit without modification
if [ "$FILE_COUNT" -ne 1 ]; then
	exit 0
fi

FILENAME="${FILES_TOUCHED%%"${NL}"*}"
# Remove any trailing newline (git output should be clean, but be safe)
FILENAME="${FILENAME%"${NL}"}"

ORIGINAL_TYPE=""
case "$COMMIT_SUMMARY" in
build:\ ?* | chore:\ ?* | ci:\ ?* | docs:\ ?* | feat:\ ?* | fix:\ ?* | perf:\ ?* | refactor:\ ?* | revert:\ ?* | style:\ ?* | test:\ ?*)
	ORIGINAL_TYPE="${COMMIT_SUMMARY%%:*}"
	;;
esac

# If pattern doesn't match or type extraction failed, exit
if [ -z "$ORIGINAL_TYPE" ]; then
	exit 0
fi

# Check if the filename already appears in the summary
case "$COMMIT_SUMMARY" in
*"$FILENAME"*) exit 0 ;;
esac

PREFIX="$ORIGINAL_TYPE: "
SUFFIX="${COMMIT_SUMMARY#"$PREFIX"}"
MODIFIED_SUMMARY="$ORIGINAL_TYPE($FILENAME): $SUFFIX"

if [ ${#MODIFIED_SUMMARY} -lt 51 ]; then
	# Write the modified summary and original body back to the commit message file
	{
		echo "$MODIFIED_SUMMARY"
		[ -n "$COMMIT_BODY" ] && echo "$COMMIT_BODY"
	} >"$COMMIT_MSG_FILE"
	echo "Modified commit message summary: $MODIFIED_SUMMARY" >&2
fi
